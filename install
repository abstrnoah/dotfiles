#!/bin/sh

# usage: sh ./install <name>
#        sh ./install
#
# Where attribute `envs.<name>` is the environment to be deployed to $HOME.
#
# If <name> is omitted, then uninstall stowed files and remove
# $HOME/.dotfiles-env. Note that this does not uninstall Nix nor remove the
# cloned $HOME/.dotfiles repository.
#
# All configuration except <name> is via the following environment variables:
#
# - HOME
#     - determines destination of ~/.dotfiles-env
# - DOTFILES_PATH
#     - seat of the live git repository
#     - default $HOME/.dotfiles
# - DEBUG
#     - whether to run with `set -x`
# - DOTFILES_INSTALL_MODE
#     - TODO not implemented
#     - one of "portable", "nonportable", "auto"
# - DOTFILES_NIX_PORTABLE
#     - path to nix-portable executable
#     - nix-portable is tried in the following order
#         - DOTFILES_NIX_PORTABLE
#         - from PATH
#         - via curl
#         - via wget
#     - if $DOTFILES_NIX_PORTABLE does not exist but nix-portable can be
#       fetched, then it will be installed $DOTFILES_NIX_PORTABLE
#     - default "$DOTFILES_PATH/nix-portable"
#
# Note that the user may not configure DOTFILES_ENV, the seat of the resulting
# dotfiles environment, which is hard-coded to $HOME/.dotfiles-env. The script
# will not overwrite this path if it does not already point to the nix store (as
# interpreted by nix-build). One reason for this is that we need to be able to
# determine if DOTFILES_ENV already is deployed so that it can be unstowed
# before deploying the new one.

# The goal of this script is to deploy the specified dotfiles environment to
# your home directory with minimal dependencies. The script tries to
# fetch/install Nix, the dotfiles repository, and any other requirements
# automatically. This means that the script can (hopefully) be run in the
# absence of the containing git repository like
#
#     sh <(curl -L https://raw.githubusercontent.com/abstrnoah/dotfiles/main/install)
#
# or after the repo has already been installed and is under development, or
# anywhere in between.
#
# Procedural outline:
# - bootstrap if Nix or $HOME/.dotfiles is missing
#     - this requires nix-portable, curl, wget, to be
#       installed, in that order of preference
#     - bootstrap means install working version of Nix and deploy dotfiles
#       repository to $HOME/.dotfiles
# - atomically (as best we can) build and deploy envs.$1
#     - unstow $HOME/.dotfiles-env/home/me if exists
#     - save old $HOME/.dotfiles-env temporarily
#     - build envs.$1 in nix store and link to $HOME/.dotfiles-env
#     - stow $HOME/.dotfiles-env/home/me to $HOME
#
# TODO:
# - support portable nix installation
# - README
# once we merge into main, update flake url

{ # wrap to avoid execution if incompletely fetched

    if test -n "${DEBUG}"; then
        set -x
    fi

    umask 0022

    oops() {
        echo "${0}:" fatal: "${@}"
        exit 1
    }

    temp_dir="$(mktemp -d \
                || oops "unable to create temporary build directory")"

    success=false
    teardown() {
        if test "${success}" = false && test -L "${DOTFILES_ENV_OLD}"; then
            mv -T "${DOTFILES_ENV_OLD}" "${DOTFILES_ENV}" \
            && stow_env \
            || echo "${0}: unable to restore env during premature termination"
        fi
        rm -rf "${temp_dir}"
    }
    trap teardown EXIT INT QUIT TERM

    NIX_INSTALLER_URL="https://releases.nixos.org/nix/nix-2.13.3/install"
    NIX_INSTALLER_SCRIPT="${temp_dir}/install_nix"
    NIX_INSTALLER_HASH="a90a3dadfe59fcebbafd361d0a0d05474008d82b17337fb94b06a5f1fa29ba32"

    NIX_PORTABLE_URL="https://github.com/DavHau/nix-portable/releases/download/v009/nix-portable"
    NIX_PORTABLE_HASH="e371dc77d8cdb4fefacdd2d8abf9b5ce013bb384a2b37def7b96e8dcb0d77790"

    test -d "${HOME}" || oops "you seem to be homeless: HOME=${HOME}"

    # DOTFILES_INSTALL_MODE="${DOTFILES_INSTALL_MODE:-auto}" # TODO not implemented

    # TODO poorly documented, check that this works
    export NIX_INSTALLER_NO_MODIFY_PROFILE=1

    DOTFILES_URL="https://github.com/abstrnoah/dotfiles"
    # TODO update flake url
    DOTFILES_FLAKE="github:abstrnoah/dotfiles/nixify"
    DOTFILES_PATH="${DOTFILES_PATH:-${HOME}/.dotfiles}"
    DOTFILES_ENV="${HOME}/.dotfiles-env"
    DOTFILES_ENV_OLD="${temp_dir}/dotfiles-env.old"
    DOTFILES_NIX_PORTABLE="${DOTFILES_NIX_PORTABLE:-${DOTFILES_PATH}/nix-portable}"

    export LOCALE_ARCHIVE=/nix/store/jbyiz1bkviwd0bvvh3jg7zzgg6gg1yjd-glibc-locales-2.35-224/lib/locale/locale-archive

    command_exists() {
        command -v "${1}" > /dev/null 2>&1
    }

    require_exec() {
        command_exists "${1}" || oops "requisite executable missing: ${1}"
    }

    require_file() {
        test -f "${1}" || oops "requisite file missing: ${1}"
    }

    nix_portable() {
        oops "you haven't bootstrapped nix-portable yet!"
    }

    bootstrap_nix_portable() {
        if command_exists nix-portable; then
            nix_portable() { nix-portable "${@}"; }
        elif command_exists "${DOTFILES_NIX_PORTABLE}"; then
            cp -T "${DOTFILES_NIX_PORTABLE}" "${temp_dir}/nix-portable" \
            || oops "failed to cp nix-portable to temp_dir"
            nix_portable() { "${temp_dir}/nix-portable" "${@}"; }
        else

            echo  "nix-portable not found, trying to fetch..."

            if command_exists curl; then
                curl --fail -L "${NIX_PORTABLE_URL}" -o "${temp_dir}/nix-portable" \
                && chmod +x "${temp_dir}/nix-portable" \
                || oops "failed to fetch nix-portable with curl"
            elif command_exists wget; then
                wget "${NIX_PORTABLE_URL}" -O "${temp_dir}/nix-portable" \
                && chmod +x "${temp_dir}/nix-portable" \
                || oops "failed to fetch nix-portable with wget"
            else
                oops "failed to bootstrap nix-portable (see README)"
            fi

            nix_portable() { "${temp_dir}/nix-portable" "${@}"; }
            cp -T "${temp_dir}/nix-portable" "${DOTFILES_NIX_PORTABLE}"

            echo "nix-portable fetched and installed at: ${DOTFILES_NIX_PORTABLE}"

        fi

    }

    nix_shell_portable() {
        nix_portable nix shell -i -k HOME -k LOCALE_ARCHIVE \
            "${DOTFILES_FLAKE}#install" \
            -c "${@}"
    }

    nix_shell() {
        require_exec nix
        nix --extra-experimental-features 'nix-command flakes' \
            shell -i -k HOME -k LOCALE_ARCHIVE \
            "${DOTFILES_FLAKE}#install" \
            -c "${@}"
    }

    repo_exists() {
        nix_shell_portable git -C "${1}" status > /dev/null 2>&1
    }

    get_hash() {
        require_file "${1}"
        nix_shell_portable sha256sum "${1}" | nix_shell_portable cut -c1-64
    }

    check_hash() {
        local h="$(get_hash "${1}")"
        test "${h}" = "${2}" || oops "hash mismatch: ${1}"
    }

    fetch() {
        echo "fetching ${1} to ${2} ..."
        nix_shell_portable curl --fail -L "${1}" -o "${2}"
        check_hash "${2}" "${3}"
    }

    git_clone() {
        echo "cloning ${1} to ${2} ..."
        nix_shell_portable git clone "${1}" "${2}" || oops "clone failed"
        repo_exists "${2}" || oops "clone exited successfully but result missing"
    }

    install_nix() {
        if command_exists nix; then return; fi

        fetch \
            "${NIX_INSTALLER_URL}" \
            "${NIX_INSTALLER_SCRIPT}" \
            "${NIX_INSTALLER_HASH}"
        require_file "${NIX_INSTALLER_SCRIPT}"

        echo "starting nix installer in multi-user mode..."
        sh "${NIX_INSTALLER_SCRIPT}" --daemon || oops "nix installer failed"
        echo "nix installer exited successfully"

        command_exists nix || oops "nix failed to appear in PATH"
    }

    fetch_dotfiles() {
        if repo_exists "${DOTFILES_PATH}"; then return; fi

        test -d "${DOTFILES_PATH}" \
        || oops "refusing to overwrite: ${DOTFILES_PATH}"
        git_clone "${DOTFILES_URL}" "${DOTFILES_PATH}"
    }

    bootstrap() {
        echo "bootstrapping..."
        bootstrap_nix_portable
        install_nix
        fetch_dotfiles
        echo "bootstrapping complete"
    }

    xstow() {
        nix_shell xstow "$@"
    }

    xstow_home() {
        local src="${1}/home"
        shift

        test -d "${src}" || oops "stow source missing: ${src}"

        xstow -t "${HOME}" -d "${src}" "${@}"
    }

    unstow_env() {
        xstow_home "${DOTFILES_ENV}" -D me || oops "failed to unstow env"
    }

    stow_env() {
        xstow_home "${DOTFILES_ENV}" me || oops "failed to stow env"
    }

    uninstall() {
        echo "uninstalling old env..."
        if test -L "${DOTFILES_ENV}"; then
            unstow_env
            mv -T "${DOTFILES_ENV}" "${DOTFILES_ENV_OLD}"
        fi
        echo "old env uninstalled"
    }

    deploy_env() {
        local env_name="${1}"

        uninstall

        test -n "${env_name}" || return

        echo "deploying env: ${env_name} ..."

        require_exec nix-build
        require_file "${DOTFILES_PATH}/default.nix"
        nix-build "${DOTFILES_PATH}/default.nix" \
            -A "envs.${env_name}" -o "${DOTFILES_ENV}" \
        || oops "failed to build env: ${env_name}"

        stow_env

        echo "deployment complete"
    }

    bootstrap
    deploy_env "${1}"

    success=true # for trap

}
